"use strict";
/**
 * This code was AUTOGENERATED using the kinobi library.
 * Please DO NOT EDIT THIS FILE, instead use visitors
 * to add features, then rerun kinobi to update it.
 *
 * @see https://github.com/metaplex-foundation/kinobi
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.CgInvalidMintAuthorityError = exports.CgAllocationGuardNotEnabledError = exports.CgAllocationLimitReachedError = exports.CgAllocationNotInitializedError = exports.CgExceededProgramListSizeError = exports.CgUnauthorizedProgramFoundError = exports.CgDuplicatedMintLimitIdError = exports.CgDuplicatedGroupLabelError = exports.CgUnlockNotEnabledError = exports.CgThawNotEnabledError = exports.CgExceededMaximumFreezePeriodError = exports.CgFreezeEscrowAlreadyExistsError = exports.CgMissingFreezePeriodError = exports.CgFreezeNotInitializedError = exports.CgFreezeGuardNotEnabledError = exports.CgMissingFreezeInstructionError = exports.CgAddressNotAuthorizedError = exports.CgMaximumRedeemedAmountError = exports.CgMissingNftError = exports.CgInvalidNftCollectionError = exports.CgAllowedMintLimitReachedError = exports.CgAllowedListNotEnabledError = exports.CgMissingAllowedListProofError = exports.CgAddressNotFoundInAllowedListError = exports.CgInvalidMintTimeError = exports.CgAfterEndDateError = exports.CgGatewayTokenInvalidError = exports.CgMissingRequiredSignatureError = exports.CgTokenTransferFailedError = exports.CgNotEnoughTokensError = exports.CgTokenBurnFailedError = exports.CgNotEnoughSOLError = exports.CgMintNotLiveError = exports.CgMintNotLastTransactionError = exports.CgCollectionUpdateAuthorityKeyMismatchError = exports.CgMissingCollectionAccountsError = exports.CgCollectionKeyMismatchError = exports.CgInstructionNotFoundError = exports.CgCandyMachineEmptyError = exports.CgExceededLengthError = exports.CgGroupNotFoundError = exports.CgRequiredGroupLabelNotFoundError = exports.CgNumericalOverflowErrorError = exports.CgMissingRemainingAccountError = exports.CgUninitializedError = exports.CgIncorrectOwnerError = exports.CgDataIncrementLimitExceededError = exports.CgPublicKeyMismatchError = exports.CgDeserializationErrorError = exports.CgInvalidAccountSizeError = void 0;
exports.getMplCandyGuardErrorFromName = exports.getMplCandyGuardErrorFromCode = exports.CgInvalidAccountVersionError = exports.CgInstructionBuilderFailedError = void 0;
const umi_1 = require("@metaplex-foundation/umi");
const codeToErrorMap = new Map();
const nameToErrorMap = new Map();
/** InvalidAccountSize: Could not save guard to account */
class CgInvalidAccountSizeError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('Could not save guard to account', program, cause);
        this.name = 'InvalidAccountSize';
        this.code = 0x1770; // 6000
    }
}
exports.CgInvalidAccountSizeError = CgInvalidAccountSizeError;
codeToErrorMap.set(0x1770, CgInvalidAccountSizeError);
nameToErrorMap.set('InvalidAccountSize', CgInvalidAccountSizeError);
/** DeserializationError: Could not deserialize guard */
class CgDeserializationErrorError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('Could not deserialize guard', program, cause);
        this.name = 'DeserializationError';
        this.code = 0x1771; // 6001
    }
}
exports.CgDeserializationErrorError = CgDeserializationErrorError;
codeToErrorMap.set(0x1771, CgDeserializationErrorError);
nameToErrorMap.set('DeserializationError', CgDeserializationErrorError);
/** PublicKeyMismatch: Public key mismatch */
class CgPublicKeyMismatchError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('Public key mismatch', program, cause);
        this.name = 'PublicKeyMismatch';
        this.code = 0x1772; // 6002
    }
}
exports.CgPublicKeyMismatchError = CgPublicKeyMismatchError;
codeToErrorMap.set(0x1772, CgPublicKeyMismatchError);
nameToErrorMap.set('PublicKeyMismatch', CgPublicKeyMismatchError);
/** DataIncrementLimitExceeded: Exceeded account increase limit */
class CgDataIncrementLimitExceededError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('Exceeded account increase limit', program, cause);
        this.name = 'DataIncrementLimitExceeded';
        this.code = 0x1773; // 6003
    }
}
exports.CgDataIncrementLimitExceededError = CgDataIncrementLimitExceededError;
codeToErrorMap.set(0x1773, CgDataIncrementLimitExceededError);
nameToErrorMap.set('DataIncrementLimitExceeded', CgDataIncrementLimitExceededError);
/** IncorrectOwner: Account does not have correct owner */
class CgIncorrectOwnerError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('Account does not have correct owner', program, cause);
        this.name = 'IncorrectOwner';
        this.code = 0x1774; // 6004
    }
}
exports.CgIncorrectOwnerError = CgIncorrectOwnerError;
codeToErrorMap.set(0x1774, CgIncorrectOwnerError);
nameToErrorMap.set('IncorrectOwner', CgIncorrectOwnerError);
/** Uninitialized: Account is not initialized */
class CgUninitializedError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('Account is not initialized', program, cause);
        this.name = 'Uninitialized';
        this.code = 0x1775; // 6005
    }
}
exports.CgUninitializedError = CgUninitializedError;
codeToErrorMap.set(0x1775, CgUninitializedError);
nameToErrorMap.set('Uninitialized', CgUninitializedError);
/** MissingRemainingAccount: Missing expected remaining account */
class CgMissingRemainingAccountError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('Missing expected remaining account', program, cause);
        this.name = 'MissingRemainingAccount';
        this.code = 0x1776; // 6006
    }
}
exports.CgMissingRemainingAccountError = CgMissingRemainingAccountError;
codeToErrorMap.set(0x1776, CgMissingRemainingAccountError);
nameToErrorMap.set('MissingRemainingAccount', CgMissingRemainingAccountError);
/** NumericalOverflowError: Numerical overflow error */
class CgNumericalOverflowErrorError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('Numerical overflow error', program, cause);
        this.name = 'NumericalOverflowError';
        this.code = 0x1777; // 6007
    }
}
exports.CgNumericalOverflowErrorError = CgNumericalOverflowErrorError;
codeToErrorMap.set(0x1777, CgNumericalOverflowErrorError);
nameToErrorMap.set('NumericalOverflowError', CgNumericalOverflowErrorError);
/** RequiredGroupLabelNotFound: Missing required group label */
class CgRequiredGroupLabelNotFoundError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('Missing required group label', program, cause);
        this.name = 'RequiredGroupLabelNotFound';
        this.code = 0x1778; // 6008
    }
}
exports.CgRequiredGroupLabelNotFoundError = CgRequiredGroupLabelNotFoundError;
codeToErrorMap.set(0x1778, CgRequiredGroupLabelNotFoundError);
nameToErrorMap.set('RequiredGroupLabelNotFound', CgRequiredGroupLabelNotFoundError);
/** GroupNotFound: Group not found */
class CgGroupNotFoundError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('Group not found', program, cause);
        this.name = 'GroupNotFound';
        this.code = 0x1779; // 6009
    }
}
exports.CgGroupNotFoundError = CgGroupNotFoundError;
codeToErrorMap.set(0x1779, CgGroupNotFoundError);
nameToErrorMap.set('GroupNotFound', CgGroupNotFoundError);
/** ExceededLength: Value exceeded maximum length */
class CgExceededLengthError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('Value exceeded maximum length', program, cause);
        this.name = 'ExceededLength';
        this.code = 0x177a; // 6010
    }
}
exports.CgExceededLengthError = CgExceededLengthError;
codeToErrorMap.set(0x177a, CgExceededLengthError);
nameToErrorMap.set('ExceededLength', CgExceededLengthError);
/** CandyMachineEmpty: Candy machine is empty */
class CgCandyMachineEmptyError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('Candy machine is empty', program, cause);
        this.name = 'CandyMachineEmpty';
        this.code = 0x177b; // 6011
    }
}
exports.CgCandyMachineEmptyError = CgCandyMachineEmptyError;
codeToErrorMap.set(0x177b, CgCandyMachineEmptyError);
nameToErrorMap.set('CandyMachineEmpty', CgCandyMachineEmptyError);
/** InstructionNotFound: No instruction was found */
class CgInstructionNotFoundError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('No instruction was found', program, cause);
        this.name = 'InstructionNotFound';
        this.code = 0x177c; // 6012
    }
}
exports.CgInstructionNotFoundError = CgInstructionNotFoundError;
codeToErrorMap.set(0x177c, CgInstructionNotFoundError);
nameToErrorMap.set('InstructionNotFound', CgInstructionNotFoundError);
/** CollectionKeyMismatch: Collection public key mismatch */
class CgCollectionKeyMismatchError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('Collection public key mismatch', program, cause);
        this.name = 'CollectionKeyMismatch';
        this.code = 0x177d; // 6013
    }
}
exports.CgCollectionKeyMismatchError = CgCollectionKeyMismatchError;
codeToErrorMap.set(0x177d, CgCollectionKeyMismatchError);
nameToErrorMap.set('CollectionKeyMismatch', CgCollectionKeyMismatchError);
/** MissingCollectionAccounts: Missing collection accounts */
class CgMissingCollectionAccountsError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('Missing collection accounts', program, cause);
        this.name = 'MissingCollectionAccounts';
        this.code = 0x177e; // 6014
    }
}
exports.CgMissingCollectionAccountsError = CgMissingCollectionAccountsError;
codeToErrorMap.set(0x177e, CgMissingCollectionAccountsError);
nameToErrorMap.set('MissingCollectionAccounts', CgMissingCollectionAccountsError);
/** CollectionUpdateAuthorityKeyMismatch: Collection update authority public key mismatch */
class CgCollectionUpdateAuthorityKeyMismatchError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('Collection update authority public key mismatch', program, cause);
        this.name = 'CollectionUpdateAuthorityKeyMismatch';
        this.code = 0x177f; // 6015
    }
}
exports.CgCollectionUpdateAuthorityKeyMismatchError = CgCollectionUpdateAuthorityKeyMismatchError;
codeToErrorMap.set(0x177f, CgCollectionUpdateAuthorityKeyMismatchError);
nameToErrorMap.set('CollectionUpdateAuthorityKeyMismatch', CgCollectionUpdateAuthorityKeyMismatchError);
/** MintNotLastTransaction: Mint must be the last instructions of the transaction */
class CgMintNotLastTransactionError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('Mint must be the last instructions of the transaction', program, cause);
        this.name = 'MintNotLastTransaction';
        this.code = 0x1780; // 6016
    }
}
exports.CgMintNotLastTransactionError = CgMintNotLastTransactionError;
codeToErrorMap.set(0x1780, CgMintNotLastTransactionError);
nameToErrorMap.set('MintNotLastTransaction', CgMintNotLastTransactionError);
/** MintNotLive: Mint is not live */
class CgMintNotLiveError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('Mint is not live', program, cause);
        this.name = 'MintNotLive';
        this.code = 0x1781; // 6017
    }
}
exports.CgMintNotLiveError = CgMintNotLiveError;
codeToErrorMap.set(0x1781, CgMintNotLiveError);
nameToErrorMap.set('MintNotLive', CgMintNotLiveError);
/** NotEnoughSOL: Not enough SOL to pay for the mint */
class CgNotEnoughSOLError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('Not enough SOL to pay for the mint', program, cause);
        this.name = 'NotEnoughSOL';
        this.code = 0x1782; // 6018
    }
}
exports.CgNotEnoughSOLError = CgNotEnoughSOLError;
codeToErrorMap.set(0x1782, CgNotEnoughSOLError);
nameToErrorMap.set('NotEnoughSOL', CgNotEnoughSOLError);
/** TokenBurnFailed: Token burn failed */
class CgTokenBurnFailedError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('Token burn failed', program, cause);
        this.name = 'TokenBurnFailed';
        this.code = 0x1783; // 6019
    }
}
exports.CgTokenBurnFailedError = CgTokenBurnFailedError;
codeToErrorMap.set(0x1783, CgTokenBurnFailedError);
nameToErrorMap.set('TokenBurnFailed', CgTokenBurnFailedError);
/** NotEnoughTokens: Not enough tokens on the account */
class CgNotEnoughTokensError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('Not enough tokens on the account', program, cause);
        this.name = 'NotEnoughTokens';
        this.code = 0x1784; // 6020
    }
}
exports.CgNotEnoughTokensError = CgNotEnoughTokensError;
codeToErrorMap.set(0x1784, CgNotEnoughTokensError);
nameToErrorMap.set('NotEnoughTokens', CgNotEnoughTokensError);
/** TokenTransferFailed: Token transfer failed */
class CgTokenTransferFailedError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('Token transfer failed', program, cause);
        this.name = 'TokenTransferFailed';
        this.code = 0x1785; // 6021
    }
}
exports.CgTokenTransferFailedError = CgTokenTransferFailedError;
codeToErrorMap.set(0x1785, CgTokenTransferFailedError);
nameToErrorMap.set('TokenTransferFailed', CgTokenTransferFailedError);
/** MissingRequiredSignature: A signature was required but not found */
class CgMissingRequiredSignatureError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('A signature was required but not found', program, cause);
        this.name = 'MissingRequiredSignature';
        this.code = 0x1786; // 6022
    }
}
exports.CgMissingRequiredSignatureError = CgMissingRequiredSignatureError;
codeToErrorMap.set(0x1786, CgMissingRequiredSignatureError);
nameToErrorMap.set('MissingRequiredSignature', CgMissingRequiredSignatureError);
/** GatewayTokenInvalid: Gateway token is not valid */
class CgGatewayTokenInvalidError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('Gateway token is not valid', program, cause);
        this.name = 'GatewayTokenInvalid';
        this.code = 0x1787; // 6023
    }
}
exports.CgGatewayTokenInvalidError = CgGatewayTokenInvalidError;
codeToErrorMap.set(0x1787, CgGatewayTokenInvalidError);
nameToErrorMap.set('GatewayTokenInvalid', CgGatewayTokenInvalidError);
/** AfterEndDate: Current time is after the set end date */
class CgAfterEndDateError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('Current time is after the set end date', program, cause);
        this.name = 'AfterEndDate';
        this.code = 0x1788; // 6024
    }
}
exports.CgAfterEndDateError = CgAfterEndDateError;
codeToErrorMap.set(0x1788, CgAfterEndDateError);
nameToErrorMap.set('AfterEndDate', CgAfterEndDateError);
/** InvalidMintTime: Current time is not within the allowed mint time */
class CgInvalidMintTimeError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('Current time is not within the allowed mint time', program, cause);
        this.name = 'InvalidMintTime';
        this.code = 0x1789; // 6025
    }
}
exports.CgInvalidMintTimeError = CgInvalidMintTimeError;
codeToErrorMap.set(0x1789, CgInvalidMintTimeError);
nameToErrorMap.set('InvalidMintTime', CgInvalidMintTimeError);
/** AddressNotFoundInAllowedList: Address not found on the allowed list */
class CgAddressNotFoundInAllowedListError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('Address not found on the allowed list', program, cause);
        this.name = 'AddressNotFoundInAllowedList';
        this.code = 0x178a; // 6026
    }
}
exports.CgAddressNotFoundInAllowedListError = CgAddressNotFoundInAllowedListError;
codeToErrorMap.set(0x178a, CgAddressNotFoundInAllowedListError);
nameToErrorMap.set('AddressNotFoundInAllowedList', CgAddressNotFoundInAllowedListError);
/** MissingAllowedListProof: Missing allowed list proof */
class CgMissingAllowedListProofError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('Missing allowed list proof', program, cause);
        this.name = 'MissingAllowedListProof';
        this.code = 0x178b; // 6027
    }
}
exports.CgMissingAllowedListProofError = CgMissingAllowedListProofError;
codeToErrorMap.set(0x178b, CgMissingAllowedListProofError);
nameToErrorMap.set('MissingAllowedListProof', CgMissingAllowedListProofError);
/** AllowedListNotEnabled: Allow list guard is not enabled */
class CgAllowedListNotEnabledError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('Allow list guard is not enabled', program, cause);
        this.name = 'AllowedListNotEnabled';
        this.code = 0x178c; // 6028
    }
}
exports.CgAllowedListNotEnabledError = CgAllowedListNotEnabledError;
codeToErrorMap.set(0x178c, CgAllowedListNotEnabledError);
nameToErrorMap.set('AllowedListNotEnabled', CgAllowedListNotEnabledError);
/** AllowedMintLimitReached: The maximum number of allowed mints was reached */
class CgAllowedMintLimitReachedError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('The maximum number of allowed mints was reached', program, cause);
        this.name = 'AllowedMintLimitReached';
        this.code = 0x178d; // 6029
    }
}
exports.CgAllowedMintLimitReachedError = CgAllowedMintLimitReachedError;
codeToErrorMap.set(0x178d, CgAllowedMintLimitReachedError);
nameToErrorMap.set('AllowedMintLimitReached', CgAllowedMintLimitReachedError);
/** InvalidNftCollection: Invalid NFT collection */
class CgInvalidNftCollectionError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('Invalid NFT collection', program, cause);
        this.name = 'InvalidNftCollection';
        this.code = 0x178e; // 6030
    }
}
exports.CgInvalidNftCollectionError = CgInvalidNftCollectionError;
codeToErrorMap.set(0x178e, CgInvalidNftCollectionError);
nameToErrorMap.set('InvalidNftCollection', CgInvalidNftCollectionError);
/** MissingNft: Missing NFT on the account */
class CgMissingNftError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('Missing NFT on the account', program, cause);
        this.name = 'MissingNft';
        this.code = 0x178f; // 6031
    }
}
exports.CgMissingNftError = CgMissingNftError;
codeToErrorMap.set(0x178f, CgMissingNftError);
nameToErrorMap.set('MissingNft', CgMissingNftError);
/** MaximumRedeemedAmount: Current redemeed items is at the set maximum amount */
class CgMaximumRedeemedAmountError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('Current redemeed items is at the set maximum amount', program, cause);
        this.name = 'MaximumRedeemedAmount';
        this.code = 0x1790; // 6032
    }
}
exports.CgMaximumRedeemedAmountError = CgMaximumRedeemedAmountError;
codeToErrorMap.set(0x1790, CgMaximumRedeemedAmountError);
nameToErrorMap.set('MaximumRedeemedAmount', CgMaximumRedeemedAmountError);
/** AddressNotAuthorized: Address not authorized */
class CgAddressNotAuthorizedError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('Address not authorized', program, cause);
        this.name = 'AddressNotAuthorized';
        this.code = 0x1791; // 6033
    }
}
exports.CgAddressNotAuthorizedError = CgAddressNotAuthorizedError;
codeToErrorMap.set(0x1791, CgAddressNotAuthorizedError);
nameToErrorMap.set('AddressNotAuthorized', CgAddressNotAuthorizedError);
/** MissingFreezeInstruction: Missing freeze instruction data */
class CgMissingFreezeInstructionError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('Missing freeze instruction data', program, cause);
        this.name = 'MissingFreezeInstruction';
        this.code = 0x1792; // 6034
    }
}
exports.CgMissingFreezeInstructionError = CgMissingFreezeInstructionError;
codeToErrorMap.set(0x1792, CgMissingFreezeInstructionError);
nameToErrorMap.set('MissingFreezeInstruction', CgMissingFreezeInstructionError);
/** FreezeGuardNotEnabled: Freeze guard must be enabled */
class CgFreezeGuardNotEnabledError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('Freeze guard must be enabled', program, cause);
        this.name = 'FreezeGuardNotEnabled';
        this.code = 0x1793; // 6035
    }
}
exports.CgFreezeGuardNotEnabledError = CgFreezeGuardNotEnabledError;
codeToErrorMap.set(0x1793, CgFreezeGuardNotEnabledError);
nameToErrorMap.set('FreezeGuardNotEnabled', CgFreezeGuardNotEnabledError);
/** FreezeNotInitialized: Freeze must be initialized */
class CgFreezeNotInitializedError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('Freeze must be initialized', program, cause);
        this.name = 'FreezeNotInitialized';
        this.code = 0x1794; // 6036
    }
}
exports.CgFreezeNotInitializedError = CgFreezeNotInitializedError;
codeToErrorMap.set(0x1794, CgFreezeNotInitializedError);
nameToErrorMap.set('FreezeNotInitialized', CgFreezeNotInitializedError);
/** MissingFreezePeriod: Missing freeze period */
class CgMissingFreezePeriodError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('Missing freeze period', program, cause);
        this.name = 'MissingFreezePeriod';
        this.code = 0x1795; // 6037
    }
}
exports.CgMissingFreezePeriodError = CgMissingFreezePeriodError;
codeToErrorMap.set(0x1795, CgMissingFreezePeriodError);
nameToErrorMap.set('MissingFreezePeriod', CgMissingFreezePeriodError);
/** FreezeEscrowAlreadyExists: The freeze escrow account already exists */
class CgFreezeEscrowAlreadyExistsError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('The freeze escrow account already exists', program, cause);
        this.name = 'FreezeEscrowAlreadyExists';
        this.code = 0x1796; // 6038
    }
}
exports.CgFreezeEscrowAlreadyExistsError = CgFreezeEscrowAlreadyExistsError;
codeToErrorMap.set(0x1796, CgFreezeEscrowAlreadyExistsError);
nameToErrorMap.set('FreezeEscrowAlreadyExists', CgFreezeEscrowAlreadyExistsError);
/** ExceededMaximumFreezePeriod: Maximum freeze period exceeded */
class CgExceededMaximumFreezePeriodError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('Maximum freeze period exceeded', program, cause);
        this.name = 'ExceededMaximumFreezePeriod';
        this.code = 0x1797; // 6039
    }
}
exports.CgExceededMaximumFreezePeriodError = CgExceededMaximumFreezePeriodError;
codeToErrorMap.set(0x1797, CgExceededMaximumFreezePeriodError);
nameToErrorMap.set('ExceededMaximumFreezePeriod', CgExceededMaximumFreezePeriodError);
/** ThawNotEnabled: Thaw is not enabled */
class CgThawNotEnabledError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('Thaw is not enabled', program, cause);
        this.name = 'ThawNotEnabled';
        this.code = 0x1798; // 6040
    }
}
exports.CgThawNotEnabledError = CgThawNotEnabledError;
codeToErrorMap.set(0x1798, CgThawNotEnabledError);
nameToErrorMap.set('ThawNotEnabled', CgThawNotEnabledError);
/** UnlockNotEnabled: Unlock is not enabled (not all NFTs are thawed) */
class CgUnlockNotEnabledError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('Unlock is not enabled (not all NFTs are thawed)', program, cause);
        this.name = 'UnlockNotEnabled';
        this.code = 0x1799; // 6041
    }
}
exports.CgUnlockNotEnabledError = CgUnlockNotEnabledError;
codeToErrorMap.set(0x1799, CgUnlockNotEnabledError);
nameToErrorMap.set('UnlockNotEnabled', CgUnlockNotEnabledError);
/** DuplicatedGroupLabel: Duplicated group label */
class CgDuplicatedGroupLabelError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('Duplicated group label', program, cause);
        this.name = 'DuplicatedGroupLabel';
        this.code = 0x179a; // 6042
    }
}
exports.CgDuplicatedGroupLabelError = CgDuplicatedGroupLabelError;
codeToErrorMap.set(0x179a, CgDuplicatedGroupLabelError);
nameToErrorMap.set('DuplicatedGroupLabel', CgDuplicatedGroupLabelError);
/** DuplicatedMintLimitId: Duplicated mint limit id */
class CgDuplicatedMintLimitIdError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('Duplicated mint limit id', program, cause);
        this.name = 'DuplicatedMintLimitId';
        this.code = 0x179b; // 6043
    }
}
exports.CgDuplicatedMintLimitIdError = CgDuplicatedMintLimitIdError;
codeToErrorMap.set(0x179b, CgDuplicatedMintLimitIdError);
nameToErrorMap.set('DuplicatedMintLimitId', CgDuplicatedMintLimitIdError);
/** UnauthorizedProgramFound: An unauthorized program was found in the transaction */
class CgUnauthorizedProgramFoundError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('An unauthorized program was found in the transaction', program, cause);
        this.name = 'UnauthorizedProgramFound';
        this.code = 0x179c; // 6044
    }
}
exports.CgUnauthorizedProgramFoundError = CgUnauthorizedProgramFoundError;
codeToErrorMap.set(0x179c, CgUnauthorizedProgramFoundError);
nameToErrorMap.set('UnauthorizedProgramFound', CgUnauthorizedProgramFoundError);
/** ExceededProgramListSize: Exceeded the maximum number of programs in the additional list */
class CgExceededProgramListSizeError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('Exceeded the maximum number of programs in the additional list', program, cause);
        this.name = 'ExceededProgramListSize';
        this.code = 0x179d; // 6045
    }
}
exports.CgExceededProgramListSizeError = CgExceededProgramListSizeError;
codeToErrorMap.set(0x179d, CgExceededProgramListSizeError);
nameToErrorMap.set('ExceededProgramListSize', CgExceededProgramListSizeError);
/** AllocationNotInitialized: Allocation PDA not initialized */
class CgAllocationNotInitializedError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('Allocation PDA not initialized', program, cause);
        this.name = 'AllocationNotInitialized';
        this.code = 0x179e; // 6046
    }
}
exports.CgAllocationNotInitializedError = CgAllocationNotInitializedError;
codeToErrorMap.set(0x179e, CgAllocationNotInitializedError);
nameToErrorMap.set('AllocationNotInitialized', CgAllocationNotInitializedError);
/** AllocationLimitReached: Allocation limit was reached */
class CgAllocationLimitReachedError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('Allocation limit was reached', program, cause);
        this.name = 'AllocationLimitReached';
        this.code = 0x179f; // 6047
    }
}
exports.CgAllocationLimitReachedError = CgAllocationLimitReachedError;
codeToErrorMap.set(0x179f, CgAllocationLimitReachedError);
nameToErrorMap.set('AllocationLimitReached', CgAllocationLimitReachedError);
/** AllocationGuardNotEnabled: Allocation guard must be enabled */
class CgAllocationGuardNotEnabledError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('Allocation guard must be enabled', program, cause);
        this.name = 'AllocationGuardNotEnabled';
        this.code = 0x17a0; // 6048
    }
}
exports.CgAllocationGuardNotEnabledError = CgAllocationGuardNotEnabledError;
codeToErrorMap.set(0x17a0, CgAllocationGuardNotEnabledError);
nameToErrorMap.set('AllocationGuardNotEnabled', CgAllocationGuardNotEnabledError);
/** InvalidMintAuthority: Candy machine has an invalid mint authority */
class CgInvalidMintAuthorityError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('Candy machine has an invalid mint authority', program, cause);
        this.name = 'InvalidMintAuthority';
        this.code = 0x17a1; // 6049
    }
}
exports.CgInvalidMintAuthorityError = CgInvalidMintAuthorityError;
codeToErrorMap.set(0x17a1, CgInvalidMintAuthorityError);
nameToErrorMap.set('InvalidMintAuthority', CgInvalidMintAuthorityError);
/** InstructionBuilderFailed: Instruction could not be created */
class CgInstructionBuilderFailedError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('Instruction could not be created', program, cause);
        this.name = 'InstructionBuilderFailed';
        this.code = 0x17a2; // 6050
    }
}
exports.CgInstructionBuilderFailedError = CgInstructionBuilderFailedError;
codeToErrorMap.set(0x17a2, CgInstructionBuilderFailedError);
nameToErrorMap.set('InstructionBuilderFailed', CgInstructionBuilderFailedError);
/** InvalidAccountVersion: Invalid account version */
class CgInvalidAccountVersionError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('Invalid account version', program, cause);
        this.name = 'InvalidAccountVersion';
        this.code = 0x17a3; // 6051
    }
}
exports.CgInvalidAccountVersionError = CgInvalidAccountVersionError;
codeToErrorMap.set(0x17a3, CgInvalidAccountVersionError);
nameToErrorMap.set('InvalidAccountVersion', CgInvalidAccountVersionError);
/**
 * Attempts to resolve a custom program error from the provided error code.
 * @category Errors
 */
function getMplCandyGuardErrorFromCode(code, program, cause) {
    const constructor = codeToErrorMap.get(code);
    return constructor ? new constructor(program, cause) : null;
}
exports.getMplCandyGuardErrorFromCode = getMplCandyGuardErrorFromCode;
/**
 * Attempts to resolve a custom program error from the provided error name, i.e. 'Unauthorized'.
 * @category Errors
 */
function getMplCandyGuardErrorFromName(name, program, cause) {
    const constructor = nameToErrorMap.get(name);
    return constructor ? new constructor(program, cause) : null;
}
exports.getMplCandyGuardErrorFromName = getMplCandyGuardErrorFromName;
//# sourceMappingURL=mplCandyGuard.js.map