"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.nftPaymentGuardManifest = void 0;
const mpl_toolbox_1 = require("@metaplex-foundation/mpl-toolbox");
const mpl_token_metadata_1 = require("@metaplex-foundation/mpl-token-metadata");
const programs_1 = require("../programs");
const generated_1 = require("../generated");
const guards_1 = require("../guards");
/**
 * The nftPayment guard allows minting by charging the
 * payer an NFT from a specified NFT collection.
 * The NFT will be transfered to a predefined destination.
 *
 * This means the mint address of the NFT to transfer must be
 * passed when minting. This guard alone does not limit how many
 * times a holder can mint. A holder can mint as many times
 * as they have NFTs from the required collection to pay with.
 */
exports.nftPaymentGuardManifest = {
    name: 'nftPayment',
    serializer: generated_1.getNftPaymentSerializer,
    mintParser: (context, mintContext, args) => {
        const nftTokenAccount = args.tokenAccount ??
            (0, mpl_toolbox_1.findAssociatedTokenPda)(context, {
                mint: args.mint,
                owner: mintContext.minter.publicKey,
            })[0];
        const [nftMetadata] = (0, mpl_token_metadata_1.findMetadataPda)(context, { mint: args.mint });
        const [destinationAta] = (0, mpl_toolbox_1.findAssociatedTokenPda)(context, {
            mint: args.mint,
            owner: args.destination,
        });
        const remainingAccounts = [
            { publicKey: nftTokenAccount, isWritable: true },
            { publicKey: nftMetadata, isWritable: true },
            { publicKey: args.mint, isWritable: false },
            { publicKey: args.destination, isWritable: false },
            { publicKey: destinationAta, isWritable: true },
            {
                publicKey: (0, mpl_toolbox_1.getSplAssociatedTokenProgramId)(context),
                isWritable: false,
            },
        ];
        if ((0, mpl_token_metadata_1.isProgrammable)(args.tokenStandard)) {
            const [nftMasterEdition] = (0, mpl_token_metadata_1.findMasterEditionPda)(context, {
                mint: args.mint,
            });
            const [ownerTokenRecord] = (0, mpl_token_metadata_1.findTokenRecordPda)(context, {
                mint: args.mint,
                token: nftTokenAccount,
            });
            const [destinationTokenRecord] = (0, mpl_token_metadata_1.findTokenRecordPda)(context, {
                mint: args.mint,
                token: destinationAta,
            });
            const tokenAuthRules = (0, programs_1.getMplTokenAuthRulesProgramId)(context);
            remainingAccounts.push(...[
                { publicKey: nftMasterEdition, isWritable: false },
                { publicKey: ownerTokenRecord, isWritable: true },
                { publicKey: destinationTokenRecord, isWritable: true },
            ]);
            if (args.ruleSet) {
                remainingAccounts.push(...[
                    { publicKey: tokenAuthRules, isWritable: false },
                    { publicKey: args.ruleSet, isWritable: false },
                ]);
            }
        }
        return { data: new Uint8Array(), remainingAccounts };
    },
    routeParser: guards_1.noopParser,
};
//# sourceMappingURL=nftPayment.js.map