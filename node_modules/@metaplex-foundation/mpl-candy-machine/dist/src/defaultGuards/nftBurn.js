"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.nftBurnGuardManifest = void 0;
const mpl_toolbox_1 = require("@metaplex-foundation/mpl-toolbox");
const mpl_token_metadata_1 = require("@metaplex-foundation/mpl-token-metadata");
const generated_1 = require("../generated");
const guards_1 = require("../guards");
/**
 * The nftBurn guard restricts the mint to holders of a predefined
 * NFT Collection and burns the holder's NFT when minting.
 *
 * This means the mint address of the NFT to burn must be
 * passed when minting. This guard alone does not limit how many
 * times a holder can mint. A holder can mint as many times
 * as they have NFTs from the required collection to burn.
 */
exports.nftBurnGuardManifest = {
    name: 'nftBurn',
    serializer: generated_1.getNftBurnSerializer,
    mintParser: (context, mintContext, args) => {
        const nftTokenAccount = args.tokenAccount ??
            (0, mpl_toolbox_1.findAssociatedTokenPda)(context, {
                mint: args.mint,
                owner: mintContext.minter.publicKey,
            })[0];
        const [nftMetadata] = (0, mpl_token_metadata_1.findMetadataPda)(context, { mint: args.mint });
        const [nftMasterEdition] = (0, mpl_token_metadata_1.findMasterEditionPda)(context, {
            mint: args.mint,
        });
        const [collectionMetadata] = (0, mpl_token_metadata_1.findMetadataPda)(context, {
            mint: args.requiredCollection,
        });
        const remainingAccounts = [
            { publicKey: nftTokenAccount, isWritable: true },
            { publicKey: nftMetadata, isWritable: true },
            { publicKey: nftMasterEdition, isWritable: true },
            { publicKey: args.mint, isWritable: true },
            { publicKey: collectionMetadata, isWritable: true },
        ];
        if ((0, mpl_token_metadata_1.isProgrammable)(args.tokenStandard)) {
            const [nftTokenRecord] = (0, mpl_token_metadata_1.findTokenRecordPda)(context, {
                mint: args.mint,
                token: nftTokenAccount,
            });
            remainingAccounts.push({ publicKey: nftTokenRecord, isWritable: true });
        }
        return { data: new Uint8Array(), remainingAccounts };
    },
    routeParser: guards_1.noopParser,
};
//# sourceMappingURL=nftBurn.js.map