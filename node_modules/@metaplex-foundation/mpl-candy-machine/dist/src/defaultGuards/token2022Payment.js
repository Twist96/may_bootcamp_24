"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.token2022PaymentGuardManifest = void 0;
const umi_1 = require("@metaplex-foundation/umi");
const serializers_1 = require("@metaplex-foundation/umi/serializers");
const generated_1 = require("../generated");
const guards_1 = require("../guards");
const SPL_TOKEN_2022_PROGRAM_ID = (0, umi_1.publicKey)('TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb');
/**
 * The token2022Payment guard allows minting by charging the
 * payer a specific amount of tokens from a certain mint acount
 * using Token2022. The tokens will be transfered to a predefined
 * destination.
 *
 * This guard alone does not limit how many times a holder
 * can mint. A holder can mint as many times as they have
 * the required amount of tokens to pay with.
 */
exports.token2022PaymentGuardManifest = {
    name: 'token2022Payment',
    serializer: generated_1.getToken2022PaymentSerializer,
    mintParser: (context, mintContext, args) => {
        const associatedTokenProgramId = context.programs.get('splAssociatedToken').publicKey;
        const sourceAta = context.eddsa.findPda(associatedTokenProgramId, [
            (0, serializers_1.publicKey)().serialize(mintContext.minter.publicKey),
            (0, serializers_1.publicKey)().serialize(SPL_TOKEN_2022_PROGRAM_ID),
            (0, serializers_1.publicKey)().serialize(args.mint),
        ])[0];
        return {
            data: new Uint8Array(),
            remainingAccounts: [
                { publicKey: sourceAta, isWritable: true },
                { publicKey: args.destinationAta, isWritable: true },
                { publicKey: args.mint, isWritable: false },
                { publicKey: SPL_TOKEN_2022_PROGRAM_ID, isWritable: false },
            ],
        };
    },
    routeParser: guards_1.noopParser,
};
//# sourceMappingURL=token2022Payment.js.map