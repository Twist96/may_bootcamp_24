"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.freezeSolPaymentGuardManifest = void 0;
const mpl_token_metadata_1 = require("@metaplex-foundation/mpl-token-metadata");
const mpl_toolbox_1 = require("@metaplex-foundation/mpl-toolbox");
const serializers_1 = require("@metaplex-foundation/umi/serializers");
const errors_1 = require("../errors");
const generated_1 = require("../generated");
const programs_1 = require("../programs");
/**
 * The freezeSolPayment guard allows minting frozen NFTs by charging
 * the payer an amount in SOL. Frozen NFTs cannot be transferred
 * or listed on any marketplaces until thawed.
 *
 * The funds are transferred to a freeze escrow until all NFTs are thaw,
 * at which point, they can be transferred (unlocked) to the configured
 * destination account.
 *
 * @see {@link FreezeSolPaymentRouteArgs} to learn more about
 * the instructions that can be executed against this guard.
 */
exports.freezeSolPaymentGuardManifest = {
    name: 'freezeSolPayment',
    serializer: generated_1.getFreezeSolPaymentSerializer,
    mintParser: (context, mintContext, args) => {
        const [freezeEscrow] = (0, generated_1.findFreezeEscrowPda)(context, {
            destination: args.destination,
            candyMachine: mintContext.candyMachine,
            candyGuard: mintContext.candyGuard,
        });
        const [nftAta] = (0, mpl_toolbox_1.findAssociatedTokenPda)(context, {
            mint: mintContext.mint,
            owner: mintContext.minter.publicKey,
        });
        return {
            data: new Uint8Array(),
            remainingAccounts: [
                { publicKey: freezeEscrow, isWritable: true },
                { publicKey: nftAta, isWritable: false },
                ...(args.nftRuleSet
                    ? [{ publicKey: args.nftRuleSet, isWritable: false }]
                    : []),
            ],
        };
    },
    routeParser: (context, routeContext, args) => {
        const { path } = args;
        switch (path) {
            case 'initialize':
                return initializeRouteInstruction(context, routeContext, args);
            case 'thaw':
                return thawRouteInstruction(context, routeContext, args);
            case 'unlockFunds':
                return unlockFundsRouteInstruction(context, routeContext, args);
            default:
                throw new errors_1.UnrecognizePathForRouteInstructionError('freezeSolPayment', path);
        }
    },
};
const initializeRouteInstruction = (context, routeContext, args) => {
    const [freezeEscrow] = (0, generated_1.findFreezeEscrowPda)(context, {
        destination: args.destination,
        candyMachine: routeContext.candyMachine,
        candyGuard: routeContext.candyGuard,
    });
    const serializer = (0, serializers_1.tuple)([(0, generated_1.getFreezeInstructionSerializer)(), (0, serializers_1.u64)()]);
    return {
        data: serializer.serialize([generated_1.FreezeInstruction.Initialize, args.period]),
        remainingAccounts: [
            { publicKey: freezeEscrow, isWritable: true },
            { signer: args.candyGuardAuthority, isWritable: false },
            { publicKey: (0, mpl_toolbox_1.getSplSystemProgramId)(context), isWritable: false },
        ],
    };
};
const thawRouteInstruction = (context, routeContext, args) => {
    const [freezeEscrow] = (0, generated_1.findFreezeEscrowPda)(context, {
        destination: args.destination,
        candyMachine: routeContext.candyMachine,
        candyGuard: routeContext.candyGuard,
    });
    const [nftFreezeAta] = (0, mpl_toolbox_1.findAssociatedTokenPda)(context, {
        mint: args.nftMint,
        owner: freezeEscrow,
    });
    const [nftAta] = (0, mpl_toolbox_1.findAssociatedTokenPda)(context, {
        mint: args.nftMint,
        owner: args.nftOwner,
    });
    const [nftMetadata] = (0, mpl_token_metadata_1.findMetadataPda)(context, { mint: args.nftMint });
    const [nftEdition] = (0, mpl_token_metadata_1.findMasterEditionPda)(context, { mint: args.nftMint });
    const [nftAtaTokenRecord] = (0, mpl_token_metadata_1.findTokenRecordPda)(context, {
        mint: args.nftMint,
        token: nftAta,
    });
    const [nftFreezeAtaTokenRecord] = (0, mpl_token_metadata_1.findTokenRecordPda)(context, {
        mint: args.nftMint,
        token: nftFreezeAta,
    });
    const data = (0, generated_1.getFreezeInstructionSerializer)().serialize(generated_1.FreezeInstruction.Thaw);
    const remainingAccounts = [
        { publicKey: freezeEscrow, isWritable: true },
        { publicKey: args.nftMint, isWritable: false },
        { publicKey: args.nftOwner, isWritable: false },
        { publicKey: nftAta, isWritable: true },
        { publicKey: nftEdition, isWritable: false },
        { publicKey: (0, mpl_toolbox_1.getSplTokenProgramId)(context), isWritable: false },
        { publicKey: (0, mpl_token_metadata_1.getMplTokenMetadataProgramId)(context), isWritable: false },
    ];
    if (!(0, mpl_token_metadata_1.isProgrammable)(args.nftTokenStandard)) {
        return { data, remainingAccounts };
    }
    remainingAccounts.push(...[
        { publicKey: nftMetadata, isWritable: true },
        { publicKey: nftFreezeAta, isWritable: true },
        { publicKey: (0, mpl_toolbox_1.getSplSystemProgramId)(context), isWritable: false },
        { publicKey: (0, mpl_toolbox_1.getSysvar)('instructions'), isWritable: false },
        { publicKey: (0, mpl_toolbox_1.getSplAssociatedTokenProgramId)(context), isWritable: false },
        { publicKey: nftAtaTokenRecord, isWritable: true },
        { publicKey: nftFreezeAtaTokenRecord, isWritable: true },
    ]);
    if (args.nftRuleSet) {
        const tokenAuthRules = (0, programs_1.getMplTokenAuthRulesProgramId)(context);
        remainingAccounts.push(...[
            { publicKey: tokenAuthRules, isWritable: false },
            { publicKey: args.nftRuleSet, isWritable: false },
        ]);
    }
    return { data, remainingAccounts };
};
const unlockFundsRouteInstruction = (context, routeContext, args) => {
    const [freezeEscrow] = (0, generated_1.findFreezeEscrowPda)(context, {
        destination: args.destination,
        candyMachine: routeContext.candyMachine,
        candyGuard: routeContext.candyGuard,
    });
    return {
        data: (0, generated_1.getFreezeInstructionSerializer)().serialize(generated_1.FreezeInstruction.UnlockFunds),
        remainingAccounts: [
            { publicKey: freezeEscrow, isWritable: true },
            { signer: args.candyGuardAuthority, isWritable: false },
            { publicKey: args.destination, isWritable: true },
            { publicKey: (0, mpl_toolbox_1.getSplSystemProgramId)(context), isWritable: false },
        ],
    };
};
//# sourceMappingURL=freezeSolPayment.js.map