"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.parseGuardRemainingAccounts = exports.parseRouteArgs = exports.parseMintArgs = exports.getGuardSetSerializer = void 0;
const umi_1 = require("@metaplex-foundation/umi");
const serializers_1 = require("@metaplex-foundation/umi/serializers");
const errors_1 = require("../errors");
function getGuardSetSerializer(context, program) {
    const manifests = context.guards.forProgram(program);
    const featuresSerializer = (0, serializers_1.reverseSerializer)((0, serializers_1.bitArray)(8, true));
    return {
        description: 'guardSet',
        fixedSize: null,
        maxSize: null,
        serialize: (set) => {
            const features = [];
            const bytes = [];
            manifests.forEach((manifest) => {
                const value = set[manifest.name] ?? (0, umi_1.none)();
                const option = (0, umi_1.isOption)(value) ? value : (0, umi_1.wrapNullable)(value);
                features.push((0, umi_1.isSome)(option));
                bytes.push((0, umi_1.isSome)(option)
                    ? manifest.serializer().serialize(option.value)
                    : new Uint8Array());
            });
            return (0, serializers_1.mergeBytes)([featuresSerializer.serialize(features), ...bytes]);
        },
        deserialize: (bytes, offset = 0) => {
            const [features, featuresOffset] = featuresSerializer.deserialize(bytes, offset);
            offset = featuresOffset;
            const guardSet = manifests.reduce((acc, manifest, index) => {
                acc[manifest.name] = (0, umi_1.none)();
                if (!(features[index] ?? false))
                    return acc;
                const serializer = manifest.serializer();
                const [value, newOffset] = serializer.deserialize(bytes, offset);
                offset = newOffset;
                acc[manifest.name] = (0, umi_1.some)(value);
                return acc;
            }, {});
            return [guardSet, offset];
        },
    };
}
exports.getGuardSetSerializer = getGuardSetSerializer;
function parseMintArgs(context, program, mintContext, mintArgs) {
    const manifests = context.guards.forProgram(program);
    return manifests.reduce((acc, manifest) => {
        const args = mintArgs[manifest.name] ?? (0, umi_1.none)();
        const argsAsOption = (0, umi_1.isOption)(args) ? args : (0, umi_1.wrapNullable)(args);
        if ((0, umi_1.isNone)(argsAsOption))
            return acc;
        const { data, remainingAccounts } = manifest.mintParser(context, mintContext, argsAsOption.value);
        return {
            data: (0, serializers_1.mergeBytes)([acc.data, data]),
            remainingAccounts: [...acc.remainingAccounts, ...remainingAccounts],
        };
    }, { data: new Uint8Array(), remainingAccounts: [] });
}
exports.parseMintArgs = parseMintArgs;
function parseRouteArgs(context, program, routeContext, guard, routeArgs) {
    const manifests = context.guards.forProgram(program);
    const guardIndex = manifests.findIndex((m) => m.name === guard);
    if (guardIndex < 0) {
        throw new errors_1.UnregisteredCandyGuardError(guard);
    }
    const manifest = manifests[guardIndex];
    const extras = manifest.routeParser(context, routeContext, routeArgs);
    return { ...extras, guardIndex };
}
exports.parseRouteArgs = parseRouteArgs;
function parseGuardRemainingAccounts(remainingAccounts) {
    const accounts = [];
    const signers = [];
    remainingAccounts.forEach((account) => {
        if ('signer' in account) {
            signers.push(account.signer);
            accounts.push({
                pubkey: account.signer.publicKey,
                isSigner: true,
                isWritable: account.isWritable,
            });
        }
        else {
            accounts.push({
                pubkey: account.publicKey,
                isSigner: false,
                isWritable: account.isWritable,
            });
        }
    });
    return [accounts, signers];
}
exports.parseGuardRemainingAccounts = parseGuardRemainingAccounts;
//# sourceMappingURL=guardSet.js.map