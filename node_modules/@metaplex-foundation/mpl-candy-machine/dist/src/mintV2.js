"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.mintV2 = void 0;
const mpl_token_metadata_1 = require("@metaplex-foundation/mpl-token-metadata");
const mpl_toolbox_1 = require("@metaplex-foundation/mpl-toolbox");
const umi_1 = require("@metaplex-foundation/umi");
const constants_1 = require("./constants");
const mintV2_1 = require("./generated/instructions/mintV2");
const guards_1 = require("./guards");
const hooked_1 = require("./hooked");
function mintV2(context, input) {
    const { mintArgs = {}, group = (0, umi_1.none)(), ...rest } = input;
    // Parsing mint data.
    const program = context.programs.get('mplCandyGuard');
    const candyMachine = (0, umi_1.publicKey)(input.candyMachine, false);
    const mintContext = {
        minter: input.minter ?? context.identity,
        payer: input.payer ?? context.payer,
        mint: (0, umi_1.publicKey)(input.nftMint, false),
        candyMachine,
        candyGuard: (0, umi_1.publicKey)(input.candyGuard ?? (0, hooked_1.findCandyGuardPda)(context, { base: candyMachine }), false),
    };
    const { data, remainingAccounts } = (0, guards_1.parseMintArgs)(context, program, mintContext, mintArgs);
    // Default token Record value.
    const tokenStandard = input.tokenStandard ?? mpl_token_metadata_1.TokenStandard.NonFungible;
    const defaultTokenRecord = (0, mpl_token_metadata_1.isProgrammable)(tokenStandard)
        ? (0, mpl_token_metadata_1.findTokenRecordPda)(context, {
            mint: (0, umi_1.publicKey)(input.nftMint, false),
            token: (0, umi_1.publicKey)(input.token ??
                (0, mpl_toolbox_1.findAssociatedTokenPda)(context, {
                    mint: (0, umi_1.publicKey)(input.nftMint),
                    owner: (0, umi_1.publicKey)(input.minter ?? context.identity),
                }), false),
        })
        : undefined;
    const ix = (0, mintV2_1.mintV2)(context, {
        ...rest,
        tokenRecord: input.tokenRecord ?? defaultTokenRecord,
        mintArgs: data,
        group,
    }).items[0];
    const [keys, signers] = (0, guards_1.parseGuardRemainingAccounts)(remainingAccounts);
    ix.instruction.keys.push(...keys);
    ix.signers.push(...signers);
    ix.bytesCreatedOnChain =
        constants_1.METADATA_SIZE + constants_1.MASTER_EDITION_SIZE + 2 * umi_1.ACCOUNT_HEADER_SIZE;
    if ((0, umi_1.isSigner)(input.nftMint)) {
        ix.bytesCreatedOnChain +=
            (0, mpl_toolbox_1.getMintSize)() + (0, mpl_toolbox_1.getTokenSize)() + 2 * umi_1.ACCOUNT_HEADER_SIZE;
    }
    if ((0, mpl_token_metadata_1.isProgrammable)(tokenStandard)) {
        ix.bytesCreatedOnChain += (0, mpl_token_metadata_1.getTokenRecordSize)() + umi_1.ACCOUNT_HEADER_SIZE;
    }
    return (0, umi_1.transactionBuilder)([ix]);
}
exports.mintV2 = mintV2;
//# sourceMappingURL=mintV2.js.map