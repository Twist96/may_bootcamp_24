"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.allowListGuardManifest = void 0;
const mpl_toolbox_1 = require("@metaplex-foundation/mpl-toolbox");
const umi_1 = require("@metaplex-foundation/umi");
const serializers_1 = require("@metaplex-foundation/umi/serializers");
const generated_1 = require("../generated");
/**
 * The allowList guard validates the minting wallet against
 * a predefined list of wallets.
 *
 * Instead of passing the entire list of wallets as settings,
 * this guard accepts the Root of a Merkle Tree created from
 * this allow list. The program can then validate that the minting
 * wallet is part of the allow list by requiring a Merkle Proof.
 * Minting will fail if either the minting address is not part of
 * the merkle tree or if no Merkle Proof is specified.
 *
 * You may use the `getMerkleRoot` and `getMerkleProof` helper
 * functions provided by the SDK to help you set up this guard.
 * Here is an example.
 *
 * ```ts
 * import { getMerkleProof, getMerkleRoot } from '@metaplex-foundation/mpl-candy-machine';
 * const allowList = [
 *   'Ur1CbWSGsXCdedknRbJsEk7urwAvu1uddmQv51nAnXB',
 *   'GjwcWFQYzemBtpUoN5fMAP2FZviTtMRWCmrppGuTthJS',
 *   'AT8nPwujHAD14cLojTcB1qdBzA1VXnT6LVGuUd6Y73Cy',
 * ];
 * const merkleRoot = getMerkleRoot(allowList);
 * const validMerkleProof = getMerkleProof(allowList, 'Ur1CbWSGsXCdedknRbJsEk7urwAvu1uddmQv51nAnXB');
 * const invalidMerkleProof = getMerkleProof(allowList, 'invalid-address');
 * ```
 *
 * Note that you will need to provide the Merkle Proof for the
 * minting wallet before calling the mint instruction via the
 * special "route" instruction of the guard.
 * See {@link AllowListRouteArgs} for more information.
 */
exports.allowListGuardManifest = {
    name: 'allowList',
    serializer: generated_1.getAllowListSerializer,
    mintParser: (context, mintContext, args) => ({
        data: new Uint8Array(),
        remainingAccounts: [
            {
                isWritable: false,
                publicKey: (0, generated_1.findAllowListProofPda)(context, {
                    merkleRoot: args.merkleRoot,
                    user: mintContext.minter.publicKey,
                    candyMachine: mintContext.candyMachine,
                    candyGuard: mintContext.candyGuard,
                })[0],
            },
        ],
    }),
    routeParser: (context, routeContext, args) => ({
        data: (0, serializers_1.array)((0, serializers_1.bytes)({ size: 32 })).serialize(args.merkleProof),
        remainingAccounts: [
            {
                isWritable: true,
                publicKey: (0, generated_1.findAllowListProofPda)(context, {
                    merkleRoot: args.merkleRoot,
                    user: (0, umi_1.publicKey)(args.minter ?? routeContext.payer),
                    candyMachine: routeContext.candyMachine,
                    candyGuard: routeContext.candyGuard,
                })[0],
            },
            { isWritable: false, publicKey: (0, mpl_toolbox_1.getSplSystemProgramId)(context) },
            ...(args.minter !== undefined
                ? [{ isWritable: false, publicKey: (0, umi_1.publicKey)(args.minter) }]
                : []),
        ],
    }),
};
//# sourceMappingURL=allowList.js.map